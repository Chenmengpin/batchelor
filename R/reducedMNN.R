#' MNN correction in reduced dimensions
#'
#' @param ... One or more matrices of low-dimensional representations where rows are cells and columns are dimensions.
#' Each object should contain the same number of columns, corresponding to the same dimensions.
#' These should have been generated by a single call to \code{\link{multiBatchPCA}}.
#' 
#' Alternatively, one or more \linkS4class{DataFrame} objects produced by previous calls to \code{reducedMNN}.
#' This should contain a \code{corrected} field of low-dimensional corrected coordinates,
#' along with information required for orthogonalization in the metadata.
#' @inheritParams fastMNN
#'
#' @return
#' A \linkS4class{DataFrame} is returned where each row corresponds to a cell, containing:
#' \itemize{
#' \item \code{corrected}, the matrix of corrected low-dimensional coordinates for each cell.
#' \item \code{batch}, the Rle specifying the batch of origin for each row.
#' }
#' Cells in the output object are always ordered in the same manner as supplied in \code{...}.
#' The metadata on this object is the same as that in the output of \code{\link{fastMNN}}.
#'
#' @details
#' \code{reducedMNN} performs the same operations as \code{\link{fastMNN}} but assumes that the PCA has already been performed.
#' This is useful as the PCA (via \code{\link{multiBatchPCA}} is often the most time-consuming part of the procedure.
#' By performing the PCA once, \code{reducedMNN} allows the MNN correction to be quickly repeated with different parameters.
#'
#' \code{reducedMNN} operates on the same principles as \code{\link{fastMNN}}, 
#' so users are referred to the documentation for the latter for more details on the effect of each of the arguments.
#' Obviously, any arguments pertaining to gene-based steps in \code{\link{fastMNN}} are not relevant here.
#' 
#' Note that \code{\link{multiBatchPCA}} will not perform cosine-normalization, 
#' so it is the responsibility of the user to cosine-normalize each batch beforehand with \code{\link{cosineNorm}} to recapitulate results of \code{\link{fastMNN}} with \code{cos.norm=TRUE}.
#' In addition, \code{\link{multiBatchPCA}} must be run on all samples at once, to ensure that all cells are projected to the same low-dimensional space.
#'
#' @author Aaron Lun
#' @examples
#' B1 <- matrix(rnorm(10000), ncol=50) # Batch 1 
#' B2 <- matrix(rnorm(10000), ncol=50) # Batch 2
#'
#' # Equivalent to fastMNN().
#' cB1 <- cosineNorm(B1)
#' cB2 <- cosineNorm(B2)
#' pcs <- multiBatchPCA(cB1, cB2)
#' out2 <- reducedMNN(pcs[[1]], pcs[[2]])
#'
#' @seealso
#' \code{\link{multiBatchPCA}}, to obtain the values to be corrected.
#'
#' \code{\link{fastMNN}}, for the version that operates on gene-expression values.
#'
#' @export
#' @importFrom BiocNeighbors KmknnParam
#' @importFrom BiocParallel SerialParam bpstart bpstop bpisup register
#' @importClassesFrom S4Vectors DataFrame
reducedMNN <- function (..., batch=NULL, k=20, restrict=NULL, ndist=3,
    merge.order=NULL, auto.merge=FALSE, auto.order=NULL, min.batch.skip=0,
    BNPARAM=KmknnParam(), BPPARAM=SerialParam())
{
    batches <- list(...)
    is.df <- vapply(batches, is, class2="DataFrame", FUN.VALUE=TRUE)
    if (any(is.df)) {
        .Deprecated(msg="re-use of 'fastMNN' outputs is deprecated")
        batches[is.df] <- lapply(batches[is.df], FUN=function(x) x$corrected)
    }

    checkBatchConsistency(batches, cells.in.columns=FALSE)
    restrict <- checkRestrictions(batches, restrict, cells.in.columns=FALSE)

    # Setting up the parallelization environment.
    old <- bpparam()
    register(BPPARAM)
    on.exit(register(old))

    if (!bpisup(BPPARAM)) {
        bpstart(BPPARAM)
        on.exit(bpstop(BPPARAM), add=TRUE)
    }

    args <- list(k=k, ndist=ndist, merge.order=merge.order, auto.merge=auto.merge, auto.order=auto.order,
        min.batch.skip=min.batch.skip, BNPARAM=BNPARAM, BPPARAM=BPPARAM)

    if (length(batches)==1L) {
        if (is.null(batch)) { 
            stop("'batch' must be specified if '...' has only one object")
        }
        divided <- divideIntoBatches(batches[[1]], batch=batch, restrict=restrict[[1]], byrow=TRUE)
        output <- do.call(.fast_mnn, c(list(batches=divided$batches, restrict=divided$restrict), args))

        d.reo <- divided$reorder
        output <- output[d.reo,,drop=FALSE]
        metadata(output)$merge.info$pairs <- .reindex_pairings(metadata(output)$merge.info$pairs, d.reo)
    } else {
        output <- do.call(.fast_mnn, c(list(batches=batches, restrict=restrict), args))

    }

    rownames(output) <- rownames(output$corrected)
    output 
}
